<!doctype html>
<html lang="en">
    <head>
    <meta charset="utf-8">
    <meta http-equiv="x-ua-compatible" content="ie=edge">
    <meta name="description" content="Bayesian inference has the potential to address shortcomings of deep neural networks (DNNs) such as poor calibration. However, scaling Bayesian methods to mo...">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="icon" type="image/x-icon" href="/blog/assets/images/cbl.png">

    <title>Bayesian Deep Learning via Subnetwork Inference · Cambridge MLG Blog</title>

    <link rel="stylesheet" href="/blog/assets/css/normalize.css">
    <link rel="stylesheet" href="/blog/assets/css/h5bp.css">
    <link rel="stylesheet" href="/blog/assets/css/solarized-light.css">
    <link rel="stylesheet" href="/blog/assets/css/style.css">
    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Anaheim">

    <!-- Preload icons from Icons8. -->
<script type="text/javascript">
    (new Image()).src = "/blog/assets/images/icons8-github-blue.png";
    (new Image()).src = "/blog/assets/images/icons8-github-white.png";
    (new Image()).src = "/blog/assets/images/icons8-link-blue.png";
    (new Image()).src = "/blog/assets/images/icons8-link-grey.png";
    (new Image()).src = "/blog/assets/images/icons8-ok.png";
    (new Image()).src = "/blog/assets/images/icons8-rss-blue.png";
    (new Image()).src = "/blog/assets/images/icons8-rss-dark.png";
    (new Image()).src = "/blog/assets/images/icons8-rss-white.png";
    (new Image()).src = "/blog/assets/images/icons8-twitter-blue.png";
    (new Image()).src = "/blog/assets/images/icons8-twitter-white.png";
</script>


    <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/modernizr/2.8.3/modernizr.min.js"></script>
    <script type="text/javascript" src="/blog/assets/links.js"></script>
    

    <script type="text/javascript">
        page_url = "https://mlg.eng.cam.ac.uk/2021/07/21/subnetwork-inference.html"
    </script>

    <script type="text/javascript">
    window.MathJax = {
        tex: {
            inlineMath: [['$', '$'], ['$$', '$$'], ['\\(', '\\)']],
            displayMath: [['$$', '$$'], ['\\[', '\\]']],
            packages: {'[+]': ['ams', 'newcommand']},
            tags: 'all',
            macros: {
                Normal: '\\mathcal{N}',
                R: '\\mathbb{R}',
                E: '\\mathbb{E}',
                C: '\\mathbb{C}',
                sd: '\\text{d}',
                pd: '\\partial',
                cond: '\\,|\\,',
                ll: '\\left\\langle',
                rr: '\\right\\rangle',
                fp: '\\operatorname{fp}',
                argmax: '\\operatorname{arg\\,max}',
                argmin: '\\operatorname{arg\\,min}',
                e: '\\varepsilon',
                code: ['{\\small \\texttt{#1}}', 1],
                parens: ['\\left( #1 \\right)', 1]
            }
        }
    };
</script>
<script type="text/javascript" id="MathJax-script" async
    src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js">
</script>
</head>

    <body>
        <!-- This input is here to make copying to clipboard work on iOS. -->
        <input type="text" id="selection-dummy" style="display: none;" contenteditable="true" readonly="false">

        <div id="wrapper">
            <nav class="mlg-navbar">
                <style>
                    .mlg-navbar {
                        font-family: 'Anaheim', sans-serif;
                        background-color: #e3e1e1;
                        padding: 13.5px;
                    }

                    .mlg-navbar a {
                        text-decoration: none;
                    }

                    .mlg-navbar-container {
                        display: flex;
                        justify-content: space-between;
                        align-items: center;
                        max-width: 1500px;
                        margin: 0 auto;
                    }

                    .mlg-navbar-brand {
                        display: flex;
                        align-items: center;
                        margin-left: 12px;
                    }

                    .mlg-navbar-logo {
                        height: 1.5rem;
                        margin-right: 8px;
                    }

                    .mlg-navbar-title {
                        color: #333;
                        font-size: 21.26px;
                    }

                    @media screen and (min-width: 1246px) {
                        .mlg-title-hide-desktop {
                            display: none;
                        }
                    }

                    @media screen and (max-width: 1246px) {
                        .mlg-title-hide-mobile {
                            display: none;
                        }
                    }

                    .mlg-navbar-nav {
                        display: flex;
                        list-style-type: none;
                        margin: 0;
                        padding: 0;
                    }

                    .mlg-nav-item {
                        margin-left: 24px;
                    }

                    .mlg-nav-link {
                        text-decoration: none;
                        color: #333;
                        font-size: 16px;
                    }

                    .mlg-nav-link:hover {
                        color: #193d8f;
                    }

                    .mlg-navbar-toggler-icon {
                        display: none;
                        width: 30px;
                        height: 30px;
                        background-image: url("data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 30 30'><path stroke='%233b4248' stroke-linecap='round' stroke-miterlimit='10' stroke-width='2' d='M4 7h22M4 15h22M4 23h22'/></svg>");
                        background-size: contain;
                        cursor: pointer;
                    }

                    @media (max-width: 768px) {
                        .mlg-navbar-container {
                            flex-wrap: wrap;
                            justify-content: flex-start;
                        }

                        .mlg-navbar-toggler-icon {
                            display: block;
                            margin-left: 15px;
                        }

                        .mlg-navbar-nav {
                            flex-direction: column;
                            width: 100%;
                            display: none;
                            margin-top: 10px;
                        }

                        .mlg-nav-item {
                            line-height: 25.5px;
                            margin: 9px 18px;
                        }

                        .mlg-navbar-nav.mlg-active {
                            display: flex;
                        }
                    }
                    footer {
                        position: absolute;
                        max-width: 100% !important;
                        background-color: #e3e1e1;
                        color: #3b4248;
                        padding-bottom: 20px;
                        padding-top: 5px;
                        text-align: center !important;
                        font-size: 14px;
                        line-height: 1;
                        z-index: 1020;
                        height: fit-content;
                    }

                    footer a {
                        color: #193d8f;
                        text-decoration: none;
                    }
                    
                    footer a:hover {
                        color: #3A88C4;
                        text-decoration: underline;
                    }
                    
                    .footer-icon {
                        display: inline-block;
                        width: 18px;
                        height: 18px;
                        background-size: contain;
                        background-repeat: no-repeat;
                        vertical-align: middle;
                        margin-right: 3px;
                        margin-bottom: 3px;
                    }
                    
                    .footer-twitter-icon {
                        background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' x='0px' y='0px' width='100' height='100' viewBox='0 0 32 32'%3E%3Cpath d='M 4.0175781 4 L 13.091797 17.609375 L 4.3359375 28 L 6.9511719 28 L 14.246094 19.34375 L 20.017578 28 L 20.552734 28 L 28.015625 28 L 18.712891 14.042969 L 27.175781 4 L 24.560547 4 L 17.558594 12.310547 L 12.017578 4 L 4.0175781 4 z M 7.7558594 6 L 10.947266 6 L 24.279297 26 L 21.087891 26 L 7.7558594 6 z'%3E%3C/path%3E%3C/svg%3E");
                    }
                    
                    .footer-twitter-icon:hover,
                    .twitter-link:hover .footer-twitter-icon {
                        background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' x='0px' y='0px' width='100' height='100' viewBox='0,0,256,256'%3E%3Cg fill='%233a88c4' fill-rule='nonzero' stroke='none' stroke-width='1' stroke-linecap='butt' stroke-linejoin='miter' stroke-miterlimit='10' stroke-dasharray='' stroke-dashoffset='0' font-family='none' font-weight='none' font-size='none' text-anchor='none' style='mix-blend-mode: normal'%3E%3Cg transform='scale(8,8)'%3E%3Cpath d='M4.01758,4l9.07422,13.60938l-8.75586,10.39063h2.61523l7.29492,-8.65625l5.77148,8.65625h0.53516h7.46289l-9.30273,-13.95703l8.46289,-10.04297h-2.61523l-7.00195,8.31055l-5.54102,-8.31055zM7.75586,6h3.19141l13.33203,20h-3.19141z'%3E%3C/path%3E%3C/g%3E%3C/g%3E%3C/svg%3E");
                    }
                    
                    .footer-github-icon {
                        background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' x='0px' y='0px' width='100' height='100' viewBox='0 0 24 24'%3E%3Cpath d='M10.9,2.1c-4.6,0.5-8.3,4.2-8.8,8.7c-0.5,4.7,2.2,8.9,6.3,10.5C8.7,21.4,9,21.2,9,20.8v-1.6c0,0-0.4,0.1-0.9,0.1c-1.4,0-2-1.2-2.1-1.9c-0.1-0.4-0.3-0.7-0.6-1C5.1,16.3,5,16.3,5,16.2C5,16,5.3,16,5.4,16c0.6,0,1.1,0.7,1.3,1c0.5,0.8,1.1,1,1.4,1c0.4,0,0.7-0.1,0.9-0.2c0.1-0.7,0.4-1.4,1-1.8c-2.3-0.5-4-1.8-4-4c0-1.1,0.5-2.2,1.2-3C7.1,8.8,7,8.3,7,7.6c0-0.4,0-0.9,0.2-1.3C7.2,6.1,7.4,6,7.5,6c0,0,0.1,0,0.1,0C8.1,6.1,9.1,6.4,10,7.3C10.6,7.1,11.3,7,12,7s1.4,0.1,2,0.3c0.9-0.9,2-1.2,2.5-1.3c0,0,0.1,0,0.1,0c0.2,0,0.3,0.1,0.4,0.3C17,6.7,17,7.2,17,7.6c0,0.8-0.1,1.2-0.2,1.4c0.7,0.8,1.2,1.8,1.2,3c0,2.2-1.7,3.5-4,4c0.6,0.5,1,1.4,1,2.3v2.6c0,0.3,0.3,0.6,0.7,0.5c3.7-1.5,6.3-5.1,6.3-9.3C22,6.1,16.9,1.4,10.9,2.1z'%3E%3C/path%3E%3C/svg%3E");
                    }
                    
                    .footer-github-icon:hover,
                    .github-link:hover .footer-github-icon {
                        background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' x='0px' y='0px' width='100' height='100' viewBox='0,0,256,256'%3E%3Cg fill='%233a88c4' fill-rule='nonzero' stroke='none' stroke-width='1' stroke-linecap='butt' stroke-linejoin='miter' stroke-miterlimit='10' stroke-dasharray='' stroke-dashoffset='0' font-family='none' font-weight='none' font-size='none' text-anchor='none' style='mix-blend-mode: normal'%3E%3Cg transform='scale(10.66667,10.66667)'%3E%3Cpath d='M10.9,2.1c-4.6,0.5 -8.3,4.2 -8.8,8.7c-0.5,4.7 2.2,8.9 6.3,10.5c0.3,0.1 0.6,-0.1 0.6,-0.5v-1.6c0,0 -0.4,0.1 -0.9,0.1c-1.4,0 -2,-1.2 -2.1,-1.9c-0.1,-0.4 -0.3,-0.7 -0.6,-1c-0.3,-0.1 -0.4,-0.1 -0.4,-0.2c0,-0.2 0.3,-0.2 0.4,-0.2c0.6,0 1.1,0.7 1.3,1c0.5,0.8 1.1,1 1.4,1c0.4,0 0.7,-0.1 0.9,-0.2c0.1,-0.7 0.4,-1.4 1,-1.8c-2.3,-0.5 -4,-1.8 -4,-4c0,-1.1 0.5,-2.2 1.2,-3c-0.1,-0.4 -0.2,-0.9 -0.2,-1.3c0,-0.4 0,-0.9 0.2,-1.3c0,-0.2 0.2,-0.3 0.3,-0.3h0.1c0.5,0.1 1.5,0.4 2.4,1.3c0.6,-0.2 1.3,-0.3 2,-0.3c0.7,0 1.4,0.1 2,0.3c0.9,-0.9 2,-1.2 2.5,-1.3h0.1c0.2,0 0.3,0.1 0.4,0.3c0,0.4 0,0.9 0,1.3c0,0.8 -0.1,1.2 -0.2,1.4c0.7,0.8 1.2,1.8 1.2,3c0,2.2 -1.7,3.5 -4,4c0.6,0.5 1,1.4 1,2.3v2.6c0,0.3 0.3,0.6 0.7,0.5c3.7,-1.5 6.3,-5.1 6.3,-9.3c0,-6 -5.1,-10.7 -11.1,-10z'%3E%3C/path%3E%3C/g%3E%3C/g%3E%3C/svg%3E");
                    }
                    @media(max-width: 767.98px) {
                        .nav-footer-center {
                            margin-top: 0 !important;
                        }
                    }
                    header {
                        height: 100px;
                        margin-bottom: 0px;
                    }
                    .header-tags{
                        text-align: right;
                        font-family: 'Roboto Condensed', sans-serif;
                        text-transform: uppercase;
                        font-variant: small-caps;
                        padding-top: .5em;
                        padding-bottom: 2.5em; 
                        margin-top: -50px;
                    }
                    .header-tags a {
                        font-size: 1.2em;
                        color: white;
                        text-decoration: none;
                        font-weight: bold; 
                        border-radius: 5px;
                        padding: 5px;
                        background: rgba(0, 0, 0, 0.5);
                    }
                    .header-tags a:hover {
                        border-bottom: 5px solid #3a88c4; 
                    }
                </style>
                <div class="mlg-navbar-container">
                    <span class="mlg-navbar-toggler-icon"></span>
                    <a href="https://mlg.eng.cam.ac.uk/" class="mlg-navbar-brand">
                        <img src="https://mlg.eng.cam.ac.uk/preview/assets/logo/logo.png" alt="Cambridge Logo" class="mlg-navbar-logo">
                        <span class='mlg-title-hide-mobile mlg-navbar-title'>Machine Learning Group, Department of Engineering, Cambridge</span>
                        <span class='mlg-title-hide-desktop mlg-navbar-title'>MLG Cambridge</span>
                    </a>
                    <ul class="mlg-navbar-nav">
                        <li class="mlg-nav-item"><a class="mlg-nav-link" href="https://mlg.eng.cam.ac.uk/about.html">About Us</a></li>
                        <li class="mlg-nav-item"><a class="mlg-nav-link" href="https://mlg.eng.cam.ac.uk/news/">News</a></li>
                        <li class="mlg-nav-item"><a class="mlg-nav-link" href="https://mlg.eng.cam.ac.uk/research/">Research</a></li>
                        <li class="mlg-nav-item"><a class="mlg-nav-link" href="https://mlg.eng.cam.ac.uk/publications/">Publications</a></li>
                        <li class="mlg-nav-item"><a class="mlg-nav-link" href="https://mlg.eng.cam.ac.uk/people/">People</a></li>
                        <li class="mlg-nav-item"><a class="mlg-nav-link" href="https://mlg.eng.cam.ac.uk/phd_programme_in_advanced_machine_learning.html">PhD Admissions</a></li>
                        <li class="mlg-nav-item"><a class="mlg-nav-link" href="/blog">Blog</a></li>
                    </ul>
                </div>
                <script>
                    document.querySelector('.mlg-navbar-toggler-icon').addEventListener('click', function () {
                        document.querySelector('.mlg-navbar-nav').classList.toggle('mlg-active');
                    });
                </script>
            </nav>

            <!-- Header Image -->
            <header>
            </header>

            <!-- Main content -->
            <div class="centered">
                    <div class="header-tags">
                        <a href="/blog">posts</a>
                        <a href="/blog/posts-by-tag">tags</a>
                    </div>

                <main>
                    <article>
    <img src="/blog/assets/images/subnetwork-inference/d_prediction.png" class="representative-image" alt="Representative image">
        
    <h1> Bayesian Deep Learning via Subnetwork Inference </h1>
    <p class="tags">
        
        
            <a href="/blog/posts-by-tag#Bayesian+inference" class="tag">Bayesian inference</a>
        
            <a href="/blog/posts-by-tag#deep+learning" class="tag">deep learning</a>
        
    </p>

    By <a href="https://edaxberger.github.io">Erik Daxberger</a>, <a href="https://enalisnick.github.io">Eric Nalisnick</a>

    <h2 id="motivation-bayesian-deep-learning-is-important-but-hard">Motivation: Bayesian deep learning is important but hard</h2>

<p>Despite their successes, accurately quantifying uncertainty in the predictions of DNNs is notoriously hard, especially if there is a shift in the data distribution between train and test time.
In practice, this might often lead to overconfident predictions, which is particularly harmful in safety-critical applications such as healthcare and autonomous driving.
One principled approach to quantify the predictive uncertainty of a neural net is to use <em>Bayesian inference</em>.</p>

<p>The standard practice in deep learning is to estimate the parameters using just a <em>single point</em> found through gradient-based optimisation. In contrast, in Bayesian deep learning (check out <a href="https://jorisbaan.nl/2021/03/02/introduction-to-bayesian-deep-learning.html">this blog post</a> for an introduction to Bayesian deep learning), the goal is to infer a <em>full posterior distribution</em> over the model’s weights. By capturing a distribution over weights, we capture a distribution over neural networks, which means that prediction essentially takes into account the predictions of (infinitely) many neural networks. Intuitively, on data points that are very distinct from the training data, these different neural nets will disagree on their predictions. This will result in high <em>predictive uncertainty</em> on such data points and therefore reduce overconfidence.</p>

<p>The problem is that modern deep neural nets are so big that even trying to approximate this posterior is highly non-trivial. We are not even talking about humongous 100-billion-parameter models like OpenAI’s GPT-3 here (<a href="https://arxiv.org/abs/2005.14165">Brown <em>et al.</em>, 2020</a>) — even for a neural net with more than just a few layers it’s hard to do good posterior inference! Therefore, it’s becoming more and more challenging to design approximate inference methods that actually scale.</p>

<p>To cope with this problem, many existing Bayesian deep learning methods make very strong and unrealistic approximations to the structure of the posterior. For example, the common <em>mean field approximation</em> approximates the posterior by a distribution which fully factorises over individual weights. Unfortunately, recent papers (<a href="https://arxiv.org/abs/1906.02530">Ovadia <em>et al.</em>, 2019</a>; <a href="https://arxiv.org/abs/1906.11537">Foong <em>et al.</em>, 2019</a>) have empirically demonstrated that such strong assumptions result in bad performance on downstream tasks such as uncertainty estimation. Can we do better than this?
$\newcommand{\vy}{\mathbf{y}}$
$\newcommand{\vw}{\mathbf{w}}$
$\newcommand{\mH}{\mathbf{H}}$
$\newcommand{\mX}{\mathbf{X}}$
$\newcommand{\D}{\mathcal{D}}$
$\newcommand{\c}{\textsf{c}}$</p>

<h2 id="idea-do-inference-over-only-a-small-subset-of-the-model-parameters">Idea: Do inference over only a small subset of the model parameters!</h2>

<p>Most existing Bayesian deep learning methods try to do inference over all the weights of the neural net. But do we actually need to estimate a posterior distribution over all weights?</p>

<p>It turns out that you often don’t need all those weights. In particular, recent research (<a href="https://arxiv.org/abs/1710.09282">Cheng <em>et al.</em>, 2017</a>) has shown that, since deep neural nets are so heavily overparametrised, it’s possible to find a small subnetwork within a neural net containing only a very small fraction of the weights, which, miraculously, can achieve the same accuracy as the full neural net. These subnetworks can be found by so-called pruning techniques.</p>

<div class="image-container">
    <img src="/blog/assets/images/subnetwork-inference/pruning.png" alt="An illustration of neural network pruning (Han et al., 2015)." id="figure-pruning" style="width: 100%; max-width: 500px" />
    
        <p class="caption">
            Figure 1: An illustration of neural network pruning (<a href="https://arxiv.org/abs/1506.02626">Han <i>et al.</i>, 2015</a>).
        </p>
    
</div>

<p>As shown in <a href="#figure-pruning">Figure 1</a>, pruning techniques typically first train the neural net, and then, after training, remove certain weights or even entire neurons according to some criterion. There has been a lot of recent interest in this research direction; for example, the best paper award at ICLR 2019 went to Jonathan Frankle and Michael Carbin’s now famous work on the lottery ticket hypothesis (<a href="https://arxiv.org/abs/1803.03635">Frankle and Carbin, 2018</a>), which showed that you can even retrain the pruned network from scratch and still achieve the same accuracy as the full network.</p>

<p>But how does this help us? We asked ourselves the exact same question about the model uncertainty: Can a full deep neural net’s model uncertainty be well-preserved by a small subnetwork’s model uncertainty? It turns out that the answer is yes, and in the remainder of this blog post, you will learn about how we came to this conclusion.</p>

<h2 id="our-proposed-approximation-to-the-posterior">Our proposed approximation to the posterior</h2>

<p>Assume that we have divided the weights $\vw$ into two disjoint subsets: (1) the subnetwork $\vw_S$ and (2) the set of all remaining weights $\{\vw_r\}_{r \in S^\c}$. We will later describe how we select the subnetwork; for now, just assume that we have it already. We propose to approximate the posterior distribution over as follows:
\begin{equation}
   p(\vw \cond \D)
   \overset{\text{(i)}}{\approx}
      p(\vw_S \cond \D)
      \prod_{r \in S^\c} \delta(\vw_r - \widehat{\vw}_r)
   \overset{\text{(ii)}}{\approx}
      q(\vw_S)
      \prod_{r \in S^\c} \delta(\vw_r - \widehat{\vw}_r)
   =: q_S(\vw).
\end{equation}
The first step (i) of our posterior approximation then involves a posterior distribution over just the subnetwork $\vw_S$, and delta functions over all remaining weights $\{\vw_r\}_{r \in S^\c}$. Put differently, we only treat the subnetwork $\vw_S$ in a probabilistic way, and assume that each remaining weight $\vw_r$ is deterministic and set to some fixed value $\widehat\vw_r$. Unfortunately, exact inference over the subnetwork is still intractable, so, in the second step (ii) of our approximation, we introduce an approximate posterior $q$ over the subnetwork $\vw_S$. Importantly, as the subnetwork is much smaller than the full network, this allows us to use expressive posterior approximations that would otherwise be computationally intractable (<em>e.g.</em> full-covariance Gaussians). That’s it.</p>

<p>There are a few questions that we still need to answer:</p>

<ol class="custom questions">
  <li>How do we choose and infer the subnetwork posterior $q(\vw_S)$? That is, what form does $q$ have, and how do we infer its parameters?</li>
  <li>How do we set the fixed values $\widehat\vw_r$ of all remaining weights $\{\vw_r\}_{r \in S^\c}$?</li>
  <li>How do we select the subnetwork $\vw_S$ in the first place?</li>
  <li>How do we make predictions with this approximate posterior?</li>
  <li>How does subnetwork inference perform in practice?</li>
</ol>

<p>Let’s start with Q1.</p>

<h2 id="q1-how-do-we-choose-and-infer-the-subnetwork-posterior-">Q1. How do we choose and infer the subnetwork posterior ?</h2>

<p>In this work, we infer a full-covariance Gaussian posterior over the subnetwork using the Laplace approximation, which is a classic approximate inference technique. If you don’t recall how the Laplace approximation works, below we provide a short summary. For more details on the Laplace approximation and a review of its use in deep learning, please refer to <a href="https://arxiv.org/abs/2106.14806">Daxberger et al. (2021)</a>.</p>

<p>The Laplace approximation proceeds in two steps.</p>
<ol>
  <li>
    <p>Obtain a point estimate over all model weights using maximum a-posteriori (short MAP) inference. In deep learning, this is typically done using stochastic gradient-based optimisation methods such as SGD.
\begin{equation}
\widehat\vw = \argmax_{\vw} \, [\log p(\vy \cond \mX, \vw) + \log p(\vw)]
\end{equation}</p>
  </li>
  <li>
    <p>Locally approximate the log-density of the posterior with a second-order Taylor expansion. This produces a full-covariance Gaussian posterior over the weights, where the mean of the Gaussian is simply the MAP estimate, and the covariance matrix of the Gaussian is the inverse Hessian $\mH$ of the loss with respect to the weights $\vw$ (averaged over the training data points):
\begin{equation}
p(\vw \cond \D) \approx q(\vw) = \Normal(\vw \cond \widehat\vw, \mH^{-1}).
\end{equation}</p>
  </li>
</ol>

<p>What this essentially does is it defines a Gaussian centered at the MAP estimate, with a covariance matrix that matches the curvature of the loss at the MAP estimate, as illustrated in <a href="#figure-laplace">Figure 2</a>.</p>

<div class="image-container">
    <img src="/blog/assets/images/subnetwork-inference/laplace.png" alt="A conceptual illustration of the Laplace approximation in one dimension (image adapted with kind permission from Richard Turner). We plot the parameter $\mathbf{w}$ ($x$-axis) against the density of the true posterior $p(\mathbf{w}\cond\mathcal{D})$ (in black) as well as that of the corresponding Laplace approximation $q(\mathbf{w})$ (in red). As we can see, $q(\mathbf{w})$ is a Gaussian centered at the mode $\widehat{\mathbf{w}}$ of the posterior $p(\mathbf{w}\cond\mathcal{D})$, with covariance matrix matching the curvature of $p(\mathbf{w}\cond\mathcal{D})$ at $\widehat{\mathbf{w}}$." id="figure-laplace" style="width: 100%; max-width: 400px" />
    
        <p class="caption">
            Figure 2: A conceptual illustration of the Laplace approximation in one dimension (image adapted with kind permission from Richard Turner). We plot the parameter $\mathbf{w}$ ($x$-axis) against the density of the true posterior $p(\mathbf{w}\cond\mathcal{D})$ (in black) as well as that of the corresponding Laplace approximation $q(\mathbf{w})$ (in red). As we can see, $q(\mathbf{w})$ is a Gaussian centered at the mode $\widehat{\mathbf{w}}$ of the posterior $p(\mathbf{w}\cond\mathcal{D})$, with covariance matrix matching the curvature of $p(\mathbf{w}\cond\mathcal{D})$ at $\widehat{\mathbf{w}}$.
        </p>
    
</div>

<p>The main advantage of the Laplace approximation, and also the reason why we use it, is that it is applied <em>post-hoc</em> on top of a MAP estimate and doesn’t require us to re-train the network. This is practically very appealing as MAP estimation is something we can do very well in deep neural nets. The main issue, however, is that it requires us to compute, store, and invert the full Hessian $\mH$ over all weights. This scales quadratically in space and cubically in time (in terms of the number of weights) and is therefore computationally intractable for modern neural nets.</p>

<p>Fortunately, in our case, we don’t actually want to do inference over <em>all</em> the weights, but only over a subnetwork. In this case, the second step of the Laplace approximation involves inferring a full-covariance Gaussian posterior over only the subnetwork weights $\vw_S$:
\begin{equation}
   p(\vw_S \cond \D) \approx q(\vw_S) = \Normal(\vw_S \cond \widehat\vw_S, \mH_S^{-1}).
\end{equation}
This is now tractable, since the subnetwork will in practice be substantially smaller than the full network, effectively giving us quadratic gains in space complexity and cubic gains in time complexity!</p>

<h2 id="q2-how-do-we-set-the-fixed-values-widehatmathbfw_r-of-all-remaining-weights-mathbfw_r_r-in-sc">Q2. How do we set the fixed values $\widehat{\mathbf{w}}_r$ of all remaining weights $\{\mathbf{w}_r\}_{r \in S^\c}$?</h2>

<p>In fact, this also answers Q2 of how to set the remaining weights not part of the subnetwork: Since the Laplace approximation requires us to first obtain a MAP estimate over all weights, it’s natural to simply leave all other weights at their MAP estimates!</p>

<p>Let’s now look at how subnetwork inference is done in practice.</p>

<h2 id="the-full-subnetwork-inference-algorithm">The full subnetwork inference algorithm</h2>

<p>Overall, our proposed subnetwork inference algorithm comprises the following four steps:</p>

<ol>
  <li>Obtain a MAP estimate over all the weights of the neural net using standard optimisation methods such as SGD (see <a href="#figure-map">Figure 3</a>).</li>
</ol>
<div class="image-container">
    <img src="/blog/assets/images/subnetwork-inference/a_map.png" alt="Step 1: Point estimation." id="figure-map" style="width: 100%; max-width: 300px" />
    
        <p class="caption">
            Figure 3: Step 1: Point estimation.
        </p>
    
</div>

<ol start="2">
  <li>Select a small subnetwork (see <a href="#figure-subnet">Figure 4</a>) — we’ll discuss in a second how this can be done in practice.</li>
</ol>
<div class="image-container">
    <img src="/blog/assets/images/subnetwork-inference/b_subnet.png" alt="Step 2: Subnetwork selection." id="figure-subnet" style="width: 100%; max-width: 300px" />
    
        <p class="caption">
            Figure 4: Step 2: Subnetwork selection.
        </p>
    
</div>

<ol start="3">
  <li>Perform Bayesian inference just over the subnetwork (see <a href="#figure-inference">Figure 5</a>). As described above, we use the Laplace approximation to infer a full-covariance Gaussian over the subnetwork, and leave all other weights at their MAP estimates.</li>
</ol>
<div class="image-container">
    <img src="/blog/assets/images/subnetwork-inference/c_inference.png" alt="Step 3: Bayesian inference." id="figure-inference" style="width: 100%; max-width: 300px" />
    
        <p class="caption">
            Figure 5: Step 3: Bayesian inference.
        </p>
    
</div>

<ol start="4">
  <li>Lastly, use the resulting mixed probabilistic–deterministic model to make predictions (see <a href="#figure-prediction">Figure 6</a>).</li>
</ol>
<div class="image-container">
    <img src="/blog/assets/images/subnetwork-inference/d_prediction.png" alt="Step 4: Prediction." id="figure-prediction" style="width: 100%; max-width: 300px" />
    
        <p class="caption">
            Figure 6: Step 4: Prediction.
        </p>
    
</div>

<p>Ok, now we know how to do inference over the subnetwork, but how do we find the subnetwork in the first place?</p>

<h2 id="q3-how-do-we-select-the-subnetwork-mathbfw_s-in-the-first-place">Q3. How do we select the subnetwork $\mathbf{w}_S$ in the first place?</h2>

<p>Recall that we want to preserve as much model uncertainty as possible with our subnetwork. A natural goal is therefore to find the subnetwork whose posterior is <em>closest</em> to the full network posterior. That is, we want to find the subset of weights that minimises some measure of discrepancy between the posterior over the full network and the posterior over the subnetwork.</p>

<p>To measure this discrepancy, we choose to use the Wasserstein distance:
\begin{align}
    &amp;\min \text{Wass}[\ \text{exact full posterior}\ |\ \text{subnetwork posterior}\ ] \nonumber \vphantom{\prod} \newline
    &amp;\qquad= \min \text{Wass}[\ p(\mathbf{w} \cond \mathcal{D})\ |\ q_S(\mathbf{w})\ ] \vphantom{\prod} \newline
    &amp;\qquad\approx \min \text{Wass}[\ \mathcal{N}\left(\mathbf{w}; \widehat{\mathbf{w}}, \mathbf{H}^{-1}\right)\ |\ \mathcal{N}(\mathbf{w}_S; \widehat{\mathbf{w}}_S, \mathbf{H}_S^{-1}) \prod_{r \in S^\c} \delta(\mathbf{w}_r - \widehat{\mathbf{w}}_r )\ ].
\end{align}
As the exact full network posterior $p(\mathbf{w} \cond \mathcal{D})$ is intractable, we here approximate it as a Gaussian $\mathcal{N}\left(\mathbf{w}; \widehat{\mathbf{w}}, \mathbf{H}^{-1}\right)$ over all weights (also estimated via the Laplace approximation). Also, as described earlier, the subnetwork posterior $q_S(\mathbf{w})$ is composed of a Gaussian $\mathcal{N}(\mathbf{w}_S; \widehat{\mathbf{w}}_S, \mathbf{H}_S^{-1})$ over the subnetwork and delta functions $\delta(\mathbf{w}_r - \widehat{\mathbf{w}}_r )$ over all other weights $\{\mathbf{w}_r\}_{r \in S^\c}$. Note that due to the delta functions, the subnetwork posterior is degenerate; this is why we use the Wasserstein distance, which remains well-defined for such degenerate distributions.</p>

<p>Unfortunately, this objective is still intractable, as it depends on all entries of the Hessian of the full network. To obtain a tractable objective, we assume that the full network posterior is factorised. By making this factorisation assumption, the Wasserstein objective now only depends on the diagonal entries of the Hessian, which are cheap to compute. I know what you’re thinking right now: “Didn’t they just tell us that the whole point of this subnetwork inference thing is to avoid making the assumption that the posterior is diagonal? And now they’re telling us that, actually, we still do have to make this assumption? This doesn’t make any sense!”</p>

<p>Well, in fact, it turns out that making the diagonal assumption <em>just for the purpose of subnetwork selection</em>, but then doing <em>full-covariance</em> Gaussian posterior inference over the subnetwork is much better than making the diagonal assumption for the purpose of inference itself (<em>i.e.</em> inference over the weights of the subnetwork and even over <em>all</em> weights), which we’ll see in the experiments later.</p>

<p>All in all, our proposed subnetwork selection procedure is as follows:</p>
<ol>
  <li>Estimate a factorised Gaussian posterior over all weights, using for example a diagonal Laplace approximation.</li>
  <li>Select those weights with the largest marginal variances. Why the weights with largest marginal variances? Well, one can show that, under the diagonal assumption, those are the weights that minimise the Wasserstein objective defined above.</li>
</ol>

<h2 id="q4-how-do-we-make-predictions-with-this-approximate-posterior">Q4. How do we make predictions with this approximate posterior?</h2>

<p>Great, we now know that a subnetwork can be found by (approximately) minimising the Wasserstein distance between the subnetwork posterior and the full network posterior. But how do we make predictions with this weird approximate posterior that is partly probabilistic and partly deterministic? We simply use all the weights of the neural net to make predictions: we integrate out the weights in the subnetwork, and just leave all other weights fixed at their MAP estimates. For integrating out the subnetwork weights, one can either use Monte Carlo or a closed-form approximation — please refer to the full paper for more details (the reference is given at the end of this blog post). Subnetwork inference therefore combines the strong predictive accuracy of the MAP estimate with the calibrated uncertainties of a Bayesian posterior.</p>

<p>Finally, we will now demonstrate the effectiveness of subnetwork inference in two experiments.</p>

<h2 id="q5-how-does-subnetwork-inference-perform-in-practice">Q5. How does subnetwork inference perform in practice?</h2>

<h3 id="experiment-1-how-does-subnetwork-inference-preserve-predictive-uncertainty">Experiment 1: How does subnetwork inference preserve predictive uncertainty?</h3>

<p>In the first experiment we train a small, 2-layer, fully-connected network with a total of 2600 weights on a 1D regression task, shown in <a href="#figure-regression">Figure 7</a>.</p>

<div class="image-container">
    <img src="/blog/assets/images/subnetwork-inference/regression.png" alt="Predictive distributions (mean $\pm$ std) for 1D regression. The numbers in parentheses denote the number of parameters over which inference was done (out of 2600 in total). Wasserstein subnetwork inference maintains richer predictive uncertainties at smaller parameter counts." id="figure-regression" style="width: 100%; max-width: 500px" />
    
        <p class="caption">
            Figure 7: Predictive distributions (mean $\pm$ std) for 1D regression. The numbers in parentheses denote the number of parameters over which inference was done (out of 2600 in total). Wasserstein subnetwork inference maintains richer predictive uncertainties at smaller parameter counts.
        </p>
    
</div>

<p>The number in brackets in the plot title denotes the number of weights over which we do inference; for example, for the MAP estimate (<a href="#figure-regression">Figure 7</a>, top left), inference was done over zero weights. As you can see, the 1D function we’re trying to fit consists of two separated clusters of data, and the goal here is to capture as much of the predictive uncertainty as possible, especially in-between those data clusters (<a href="https://arxiv.org/abs/1906.11537">Foong <em>et al.</em>, 2019</a>). As expected, the point estimate (<a href="#figure-regression">Figure 7</a>, top left) doesn’t capture any uncertainty, but instead makes confident predictions even in regions where there’s no data, which is bad.</p>

<p>On the other extreme, we can infer a full covariance Gaussian posterior over all the 2600 weights using a Laplace approximation (<a href="#figure-regression">Figure 7</a>, top middle), which is only tractable here due to the small model size. As we can see, a full-covariance Gaussian posterior is able to capture predictive uncertainty both at the boundaries and in-between the data clusters, so we will consider this to be the ideal, ground-truth posterior for this experiment.</p>

<p>Of course, in larger-scale settings, a full-covariance Gaussian would be intractable, so people often resort to diagonal approximations which assume full independence between the weights (<a href="#figure-regression">Figure 7</a>, top right). Unfortunately, as we can see, even though we do inference over all 2600 weights, due to the diagonal assumption we sacrifice a lot of the predictive uncertainty, especially in-between the two data clusters, where it’s only marginally better than the point estimate.</p>

<p>Now what about our proposed subnetwork inference method? First, let’s try doing full-covariance Gaussian inference over only 50% (that is, 1300) of the weights, found using the described Wasserstein minimisation approach (<a href="#figure-regression">Figure 7</a>, bottom left). As we can see, this approach captures predictive uncertainty much better than the diagonal posterior, and is even quite close to the full-covariance Gaussian over all weights. Well, but 50% is still quite a lot of weights, so let’s try to go even smaller, much smaller, to only 3% of the weights, which corresponds to just 78 weights here (<a href="#figure-regression">Figure 7</a>, bottom middle). Even then, we’re still much better off than the diagonal Gaussian. Let’s push this to the extreme, and estimate a full-covariance Gaussian over as little as 1% (that is, 26) of the weights (<a href="#figure-regression">Figure 7</a>, bottom right). Perhaps surprisingly, even with 1% of weights remaining, we do significantly better than the diagonal baseline, and are able to capture significant in-between uncertainty!</p>

<p>Overall, the take-away from this experiment is that doing expressive inference over a very small, but carefully chosen subnetwork, and capturing weight correlations just within that subnetwork can preserve more predictive uncertainty than a method that does inference over all the weights, but ignores weight correlations.</p>

<h3 id="experiment-2-how-robust-is-subnetwork-inference-to-distribution-shift">Experiment 2: How robust is subnetwork inference to distribution shift?</h3>

<p>Ok, 1D regression is fun, but we’re of course interested in scaling this to more realistic settings. In this second experiment, we consider the task of image classification under distribution shift. This task is much more challenging than 1D regression, so the model that we use is significantly larger than before: we use a ResNet-18 model with over 11 million weights, and, to remain tractable, we do inference over as little as 42 thousand (which is only around 0.38%) of the weights, again found using Wasserstein minimisation.</p>

<p>We consider five baselines: the MAP estimate, a diagonal Laplace approximation over all 11M weights, Monte Carlo (MC) dropout over all weights (<a href="https://arxiv.org/abs/1506.02142">Gal and Ghahramani, 2015</a>), Variational Online Gauss-Newton (short VOGN, <a href="https://arxiv.org/abs/1906.02506">Osawa <em>et al.</em>, 2019</a>), which estimates a factorised Gaussian over all weights, a Deep Ensemble (<a href="https://arxiv.org/abs/1612.01474">Lakshminarayanan <em>et al.</em>, 2017</a>) of 5 independently trained ResNet-18 models, and Stochastic Weight Averaging Gaussian (short SWAG, <a href="https://arxiv.org/abs/1902.02476">Maddox <em>et al.</em>, 2019</a>), which estimates a low-rank plus diagonal posterior over all weights. As another baseline, we also consider subnetwork inference with a <em>randomly selected subnetwork</em> (denoted <em>Ours (Rand)</em>), which will allow us to assess the impact of how the subnetwork is chosen.</p>

<div class="image-container">
    <img src="/blog/assets/images/subnetwork-inference/benchmarks.png" alt="Example images from the (top) rotated MNIST and (bottom) corrupted CIFAR-10 benchmarks. (Top) An image of the digit 2 is increasingly rotated. (Bottom) An image of a dog is increasingly blurred." id="figure-benchmarks" style="width: 100%; max-width: 450px" />
    
        <p class="caption">
            Figure 8: Example images from the (top) rotated MNIST and (bottom) corrupted CIFAR-10 benchmarks. (Top) An image of the digit 2 is increasingly rotated. (Bottom) An image of a dog is increasingly blurred.
        </p>
    
</div>

<p>We consider two benchmarks for evaluating robustness to distribution shift which were recently proposed by <a href="https://arxiv.org/abs/1906.02530">Ovadia <em>et al.</em> (2019)</a> (<a href="#figure-benchmarks">Figure 8</a>): firstly, we have rotated MNIST, where the model is trained on the standard MNIST training set, and then at test time evaluated on increasingly rotated MNIST digits (as for example shown for the digit 2 in <a href="#figure-benchmarks">Figure 8</a>, top); and secondly, we consider corrupted CIFAR-10, where we again train on the standard CIFAR-10 training set, but then evaluate on corrupted CIFAR-10 images; the test set contains over a dozen different corruption types, with five levels of increasing corruption severity (in this example, the image of a dog in <a href="#figure-benchmarks">Figure 8</a>, bottom, is getting more and more blurry from left to right).</p>

<div class="image-container">
    <img src="/blog/assets/images/subnetwork-inference/mnist.png" alt="Results on the rotated MNIST benchmark, showing the mean $\pm$ std of the test error (top) and log-likelihood (bottom) across three different seeds. Subnetwork inference achieves better uncertainty calibration and robustness to distribution shift than point-estimated networks and other Bayesian deep learning approaches (except for VOGN), while retaining accuracy." id="figure-mnist" style="width: 100%; max-width: 450px" />
    
        <p class="caption">
            Figure 9: Results on the rotated MNIST benchmark, showing the mean $\pm$ std of the test error (top) and log-likelihood (bottom) across three different seeds. Subnetwork inference achieves better uncertainty calibration and robustness to distribution shift than point-estimated networks and other Bayesian deep learning approaches (except for VOGN), while retaining accuracy.
        </p>
    
</div>

<p>Let’s start with rotated MNIST (<a href="#figure-mnist">Figure 9</a>). On the x-axis, we have the degree of rotation, and on the y-axis, we plot two different metrics: on top, we plot the test errors achieved by the different methods (where lower values are better), and on the bottom, we plot the corresponding log-likelihood, as a measure of calibration (where higher values are better). Here, we see that MAP, diagonal Laplace, MC dropout, the deep ensemble, SWAG, and the random subnetwork baseline all perform roughly similarly in terms of calibration (<a href="#figure-mnist">Figure 9</a>, bottom): their calibration becomes worse as we increase the degree of rotation; in contrast to that, subnetwork inference (shown in dark blue) remains much better calibrated, even at high degrees of rotation. The only competitive method here is VOGN, which slightly outperforms subnetwork inference in terms of calibration. Importantly, observe that this increase in robustness does <em>not</em> come at cost of accuracy (<a href="#figure-mnist">Figure 9</a>, top): Wasserstein subnetwork inference (as well as VOGN) retain the same accuracy as the other methods.</p>

<div class="image-container">
    <img src="/blog/assets/images/subnetwork-inference/cifar10.png" alt="Results on the corrupted CIFAR-10 benchmark, showing the mean $\pm$ std of the test error (top) and log-likelihood (bottom) across three different seeds. Subnetwork inference achieves better uncertainty calibration and robustness to distribution shift than point-estimated networks and other Bayesian deep learning approaches, while retaining accuracy." id="figure-cifar10" style="width: 100%; max-width: 450px" />
    
        <p class="caption">
            Figure 10: Results on the corrupted CIFAR-10 benchmark, showing the mean $\pm$ std of the test error (top) and log-likelihood (bottom) across three different seeds. Subnetwork inference achieves better uncertainty calibration and robustness to distribution shift than point-estimated networks and other Bayesian deep learning approaches, while retaining accuracy.
        </p>
    
</div>

<p>Now let’s look at corrupted CIFAR10 (<a href="#figure-cifar10">Figure 10</a>). There, the story is somewhat similar: we plot the corruption severity on the x-axis versus the error (<a href="#figure-cifar10">Figure 10</a>, top) and log-likelihood (<a href="#figure-cifar10">Figure 10</a>, bottom) on the y-axis. Here, MAP, diagonal Laplace, MC dropout and the random subnetwork baseline are all poorly calibrated (<a href="#figure-cifar10">Figure 10</a>, bottom). VOGN, SWAG and deep ensembles are a bit better calibrated, but are still significantly outperformed by subnetwork inference (again in dark blue), even at high corruption severities. Importantly, the improved robustness of Wasserstein subnetwork inference again does <em>not</em> compromise accuracy (<a href="#figure-cifar10">Figure 10</a>, top). In contrast, the accuracy of VOGN suffers on this dataset.</p>

<p>Overall, the take-away from this experiment is that subnetwork inference is better calibrated and therefore more robust to distribution shift than state-of-the-art baselines for uncertainty estimation in deep neural nets.</p>

<h2 id="take-home-message">Take-home message</h2>

<p>To conclude, in this blog post, we described subnetwork inference, which is a Bayesian deep learning method that does expressive inference over a carefully chosen subnetwork within a neural network. We also showed some empirical results suggesting that this works better than doing crude inference over the full network. There remain clear limitations of this work that deserve more investigation in the future: The most important one is to develop better subnetwork selection strategies that avoid the potentially restrictive approximations we use (<em>i.e.</em> the diagonal approximation to the posterior covariance matrix).</p>

<p>Thanks a lot for reading this blog post! If you want to learn more about this work, please feel free to check out our full ICML 2021 paper:</p>
<ul>
  <li>Erik Daxberger, Eric Nalisnick, James Urquhart Allingham, Javier Antorán, José Miguel Hernández-Lobato. <a href="https://arxiv.org/abs/2010.14689">Bayesian Deep Learning via Subnetwork Inference</a>. In <em>ICML 2021</em>.</li>
</ul>

<p>Finally, we would like to thank Stratis Markou, Wessel Bruinsma and Richard Turner for many helpful comments on this blog post!</p>



    
        <nav>
            
                <div class="prev"><a href="/blog/2021/04/30/reinforcement-learning-for-3d-molecular-design.html">&laquo; Reinforcement Learning for 3D Molecular Design</a></div>
            
            
                <div class="next"><a href="/blog/2021/11/24/ngvi-bnns-part-2.html">Natural-Gradient Variational Inference 2: ImageNet-scale &raquo;</a></div>
            
        </nav>
    

    <date>
        Published on 21 July 2021.
        
    </date>

    
        
        <div id="disqus_thread"></div>
        <script type="text/javascript">
            var disqus_config = function() {
                this.page.url = 'https://mlg.eng.cam.ac.uk/blog/2021/07/21/subnetwork-inference.html/development';
                this.page.identifier = '/2021/07/21/subnetwork-inference/development';
            };
            (function() {
                var d = document;
                s = d.createElement('script');
                s.src = 'https://mlg-blog.disqus.com/embed.js';
                s.setAttribute('data-timestamp', +new Date());
                (d.head || d.body).appendChild(s);
                $('#enable-disqus-button').css('display', 'none');
            })()
        </script>
        <noscript>
            Please enable JavaScript to view the comments powered by <a href="https://disqus.com/?ref_noscript" rel="nofollow">Disqus.</a>
        </noscript>
    
</article>

                </main>
            </div>

            <footer id="footer">
                <style>#footer p{text-align: center !important;}</style>
                <p><a href="https://mlg.eng.cam.ac.uk/">Cambridge Machine Learning Group</a>. Follow us on <a href="https://twitter.com/CambridgeMLG" class="twitter-link"><span class="footer-icon footer-twitter-icon"></span>@CambridgeMLG</a> and check out our GitHub <a href="https://github.com/cambridge-mlg" class="github-link"><span class="footer-icon footer-github-icon"></span>Cambridge-MLG</a>.</p>
                <p>This blog is designed by <a href="https://wesselb.github.io">Wessel</a> & <a href="https://shravangoswami.com/">Shravan</a>!</p>
                <p>Powered by <a href="https://jekyllrb.com/">Jekyll</a>. Icons by <a href="https://icons8.com">Icons8</a>. <a href="/blog/feed.xml" id="feed-button">Feed</a>. &copy; <a href="https://mlg.eng.cam.ac.uk/">Cambridge Machine Learning Group</a>.</p>
            </footer>

        </div>

        
    <!-- Google analytics is only enabled for production. -->

    </body>
</html>
